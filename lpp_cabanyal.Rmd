---
title: "LPP_CABANYAL"
author: "Dario Quishpe"
date: "`r Sys.Date()`"
output: html_document
---


```{r}
library(tsibble)
library(tidyverse)
library(readxl)
library(sf)
library(leaflet)
library(deldir)
library(spatstat)
#install.packages("tigris")
library(tigris)
library(spatstat.geom)
library(spatstat.linnet)
#install.packages("spNetwork")
library(spNetwork)
library(sp)
library(maps)
library(stars)
library(terra)
#install.packages("sfnetworks")
library(sfnetworks)
#install.packages("PBSmapping")
library(PBSmapping)
library(tmap)
library(gridExtra)
library(grid)
library(jpeg)
#install.packages("raster")
library(raster)
pacman::p_load(tidyverse,sf,mapview)
```

```{r}
BASE<-read.csv("obs_data_112Valencia (1).csv", sep=",", header=TRUE)
dim(BASE)
BASE<-BASE |> filter(year<=2019) 
dim(BASE)
head(BASE)
```


```{r}
BASE<-read.csv("obs_data_112Valencia (1).csv", sep=",", header=TRUE) 
puntos<-BASE|>filter(year<=2019) |> 
  st_as_sf(coords=c("crime_lon","crime_lat"),crs= 4258)

#mapview(puntos, map.types = "CartoDB.Voyager")

puntos

ventana <- st_read("shape files-20221031T083303Z-001/shape files/valencia_outline.shp",quiet=TRUE)
y <- st_read("shape files-20221031T083303Z-001/shape files/valencia_road.shp",quiet=TRUE)
```


```{r}

y<-st_transform(y, crs = st_crs(puntos))
barrio<-st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
#plot(barrio)
a<-"112"
#y<-st_transform(y, crs = st_crs(puntos))
barrio<-st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
barrio<-barrio |> filter(coddistbar==a)
barrio<-st_transform(barrio, crs = st_crs(puntos))
interseccion<-st_intersection(y,barrio)
plot(interseccion)
puntos <- st_transform(puntos,st_crs(barrio))
puntos_barrio<-st_intersection(puntos,barrio)
plot(puntos_barrio)
calles_barrio<- interseccion[st_geometry_type(interseccion) == "LINESTRING", ]

```



```{r}
puntos_grafica<-puntos_barrio 
dim(puntos_grafica)
dim(puntos)
ggplot()+geom_sf(data = ventana,color="black",size=20)+geom_sf(data = calles_barrio,color="black")+geom_sf(data = puntos_grafica,aes(),size=1.5,color="#C8DC02")+
        theme(axis.text.x = element_text(angle =90, vjust = 0.5, hjust = 1),strip.background = element_rect(fill = "lightblue"))


```



```{r}
st<-puntos_barrio |> mutate(crime_date=as.Date(crime_date,format = "%m/%d/%Y"))
stmy<-st |>mutate(anio_mes=format(crime_date,"%Y")) |> 
        group_by(anio_mes) |> summarise(Numero_de_Registros=n())

stmy$Tiempo <-yearmonth(stmy$anio_mes)
ST<-stmy |>  as_tsibble(index = Tiempo) |> select(Tiempo,Numero_de_Registros)
ST %>%
  autoplot() +
  geom_point(color = "black") +  
  geom_line(color = "blue") +    # Establecer título
  theme_bw()  
```

```{r}
diadelasemana<-puntos_barrio |> group_by(week_day_name) |> summarise(Observaciones=n()) |> arrange(Observaciones)
horadeldia<-puntos_barrio |> group_by(crime_hour) |> summarise(Observaciones=n()) |> arrange(crime_hour)

suma<-horadeldia |> filter(crime_hour>=18| crime_hour<=1)
sum(suma$Observaciones)
sum(horadeldia$Observaciones)
diadelasemana$week_day_name <- factor(diadelasemana$week_day_name, levels = c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"),
                              labels = c("Lun", "Mar", "Miér", "Jue", "Vier", "Sáb", "Dom"))

color_palette <- colorRampPalette(c("yellow", "orange","red"))

dias<-ggplot(diadelasemana, aes(x = week_day_name, y = Observaciones, fill = Observaciones)) +
  geom_bar(stat = "identity") +geom_text(aes(label = Observaciones), vjust = -0, color = "black", size = 3)+
  scale_fill_gradientn(colours = color_palette(nrow(diadelasemana))) + 
  labs(x = "Día de la semana", y = "Observaciones") +
  scale_x_discrete(labels = function(x) gsub("Tuesday", "Mar", gsub("Monday", "Lun", gsub("Wednesday", "Miér", gsub("Thursday", "Jue", gsub("Friday", "Vier", gsub("Saturday", "Sáb", gsub("Sunday", "Dom", x)))))))) +
  theme_minimal() +theme(plot.margin = margin(5, 0, 0, 0, "mm"),
        panel.spacing = unit(10, "lines"))+
  theme(axis.text.x = element_text(angle = 360, hjust = 1)) 

horas<-ggplot(horadeldia, aes(x = crime_hour, y = Observaciones, fill = Observaciones)) +
  geom_bar(stat = "identity") +geom_text(aes(label = Observaciones), vjust = -0.05, color = "black", size = 3, angle = 90, position = position_stack(vjust = 0.9))+
  scale_fill_gradientn(colours = color_palette(nrow(horadeldia))) + 
  labs(x = "Hora del día", y = "Observaciones") +theme(plot.margin = margin(2, 2, 2, 2, "mm"),
        panel.spacing = unit(0, "lines"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 0, hjust = 1)) 

grid.arrange(dias,horas)

```



```{r}
tm_shape(calles_barrio) + 
  tm_lines("black") + 
  tm_shape(puntos_barrio) + 
  tm_dots(col = "blue", size = 0.2)
```


```{r}
ventana<- st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
ventana<-ventana |> filter(coddistbar==a)
ventana1 <- st_transform(ventana, crs = st_crs("EPSG:32630"))
ventana2<-st_union(ventana1[1])
window<-st_coordinates(st_reverse(ventana2[1]))
a<-st_coordinates(st_reverse(ventana2[1]))
window<-owin(poly=a[,c("X","Y")])
plot(window)



target_crs <- st_crs("+proj=utm +zone=30 +north +datum=WGS84 +units=m +no_defs")
a_sf_reprojected <- st_transform(puntos, target_crs)

app <- ppp( x = st_coordinates(a_sf_reprojected)[,1],
            y = st_coordinates(a_sf_reprojected)[,2],
            marks = c(1:3221),
            window = window)

plot(app)

#app<-rjitter(app, retry = TRUE, nsim = 1, drop = TRUE)

unique(app)
unique(app, rule="deldir")
options(repr.plot.width = 50, repr.plot.height = 30)
plot(quadratcount(app, nx = 13, ny = 8))
quadrat.test(app, nx = 13, ny = 8)
```
```{r}
grid <- ventana%>%
  st_make_grid(n = c(13,8)) %>%
  st_intersection(ventana) %>% 
   st_cast("MULTIPOLYGON") %>%
  st_sf()
plot(grid)
puntos_barrio <- st_transform(puntos_barrio, crs = st_crs(grid))

inter <- st_intersects(grid, puntos_barrio)
grid$count <- lengths(inter)
ggplot(grid) + geom_sf(aes(fill = count))


ggplot(grid) + geom_sf(aes(fill = count))+
scale_fill_continuous(type = "viridis")



grid.selec <- grid
# Crear el gráfico
grilla <- ggplot(grid.selec) + 
  geom_sf(aes(fill = count)) +
  geom_sf_text(aes(label = count), size = 3, color = "white") +  # Ajusta el tamaño aquí
  scale_fill_continuous(type = "viridis") +
  theme(
    axis.text = element_text(size = 12, face = "bold"),  # Agrega negrita aquí
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)
  ) +
  theme(
    plot.margin = margin(2, 2, 2, 2, "mm"),
    panel.spacing = unit(0, "lines")
  )

# Mostrar el gráfico
grilla
```


```{r}

#Estimaciones de sigma 
estimacion1<-bw.diggle(app)
estimacion2<-bw.ppl(app)
estimacion3<-bw.scott(app)
plot(density.ppp(app,sigma = estimacion1,edge = T),main=paste("Diggle"))
plot(density.ppp(app,sigma = estimacion2,edge = T),main=paste("LH-crossvalidation"))
plot(density.ppp(app,sigma = estimacion3[1],edge = T),main=paste(""))
plot(density.ppp(app,sigma = estimacion3[2],edge = T),main=paste("Scott2"))
estimacion3[1]
estimacion3[2]
```
```{r}
K_function <- Kest(app)
summary(K_function)
plot(K_function, main = "Función K(r)")
K_functioninom <- Kinhom(app,r = seq(0,300,by=0.2))
summary(K_functioninom)
plot(K_functioninom, main = "Función K(r) no homogéneo")
plot(Gest(app))
```

```{r}
# Graficar la red vial con ggplot2
# Extraer las líneas y los nodos
par(mar = c(2.5,2.5,1,1))
plot(red_vial_ln, col = '#017308', pch = 18, lwd = 1, cex = 2,graticule = TRUE, axes = TRUE)
```



```{r}
#ANALISIS SOLO CON M1 DEPENDIENTE DE LA POSICION 
#auxiliar<-st_union(calles_distrito1)
#plot(auxiliar)
red_vial_ln<- as_sfnetwork(calles_barrio)
plot(red_vial_ln)
calles_barrio <- st_transform(calles_barrio, crs = "+proj=utm +zone=30 +datum=WGS84")
puntos_barrio <- st_transform(puntos_barrio, crs = "+proj=utm +zone=30 +datum=WGS84")
red_vial_ln <- st_transform(red_vial_ln, crs = "+proj=utm +zone=30 +datum=WGS84")
red_vial_ln <- as.linnet(red_vial_ln)
lpp_VALE <- lpp(app,red_vial_ln)
#plot(lpp_VALE)
#lambdahat <- density.lpp(lpp_VALE,sigma = 150,distance = "euclidean",continuous = TRUE,kernel = "gaussian" )
#plot(lambdahat)

lambda <- density.lpp(lpp_VALE,sigma = 77.26966 ,distance = "euclidean")
plot(lambda)
lpp_VALE<-unmark(lpp_VALE)
m1<-lppm(lpp_VALE ~ 1)
r <- seq(0, 300, by=20)
k_finom<-linearKinhom(lpp_VALE,lambda = m1,r)
plot(k_finom,main="Función K no homogénea")
plot(lpp_VALE, pch=19,main=" ",cex = 1.2,cols = "#FFC278")
plot(red_vial_ln)
```
```{r}

plot(lpp_VALE, col = '#FFC278', pch = 16, lwd = 1, cex = 1,graticule = TRUE, axes = TRUE)
```



```{r}

EIP <- predict(m1)
#plot(EIP)

 # Matern cluster process on a linear network
 # Centers = (x,y)-coordinates of parent points
 # R = The R parameter of the Matern cluster process
 # alpha = The alpha parameter of the Matern cluster process
 # LL = The linear network on which the point pattern should be simulated.
rMatClustlpp <- function(Centers, R, alpha, LL) {
X <- array(0,0)
Y <- array(0,0)
for(p in 1:length(Centers$data$x)) {
BBCOutD <- disc(radius=R, centre=c(Centers$data$x[p],
Centers$data$y[p]),
npoly = 32)
BBCD <- intersect.owin(LL$window, BBCOutD)
if(volume(LL[BBCOutD])>0) {
Xp <- rpoislpp(alpha/volume(LL[BBCOutD]), L=LL[BBCD])
X <- append(X, as.numeric(Xp$data$x))
Y <- append(Y, as.numeric(Xp$data$y))
}
}
lpp(cbind(X,Y), LL)
}
```



```{r}
nsim <- 10
valpha <- seq(5, 30, by=6)
vR <- seq(100, 1000, by=350)

```


```{r}
set.seed(2023)
Contrast <- array(0, c(length(valpha), length(vR)))
for(i in 1:length(valpha)) {
  for(j in 1:length(vR)) {
  # Compute the average K of 10 simulation from the model
  KMC <- array(0,length(r))
  for(s in 1:nsim) {
  # Centers from a Poisson process
  Centers <- rpoislpp(EIP/valpha[i], L=lpp_VALE[['domain']])
  XX <- rMatClustlpp(Centers, vR[j], valpha[i], lpp_VALE[['domain']])
  KMC <- KMC + linearKinhom(XX, lambda = m1, r=r)$est
  }
  # Compute the difference between estimated and average K
  Contrast[i,j] <- sqrt(sum((k_finom$est-KMC/nsim)^2))
  }
}

```


```{r}
 plot(as.im(Contrast), main="Values of Contrasts")
 # Finding the minimum value of the contrast
 id <- which(Contrast == min(Contrast), arr.ind = TRUE)
 alpha <- valpha[id[,1]]
 R <- vR[id[,2]]
 # Chosen values

```


```{r}
# Centers from a Poisson process
Centers <- rpoislpp(EIP/alpha, L=lpp_VALE[['domain']])
par(mfrow=c(1,2))
plot(Centers)
XX <- rMatClustlpp(Centers, R, alpha, lpp_VALE[['domain']])
plot(XX, main="A realization of the model")
```


```{r}
#ANALISIS CON COVARIABLES
## CREANDO VARIABLES
pnight <- puntos_barrio$atm_dist
Datm <- density(app, weights=pnight, sigma=77.26966)
plot(Datm)

pnight <- puntos_barrio$bank_dist
Dbank <- density(app, weights=pnight, sigma=77.26966)
plot(Dbank)

pnight <- puntos_barrio$bar_dist
Dbar <- density(app, weights=pnight, sigma=77.26966)
plot(Dbank)

pnight <- puntos_barrio$cafe_dist
Dcafe <- density(app, weights=pnight, sigma=77.26966)
plot(Dcafe)

pnight <- puntos_barrio$industrial_dist
Dindustrial <- density(app, weights=pnight, sigma=77.26966)
plot(Dindustrial)

pnight <- puntos_barrio$market_dist
Dmarket <- density(app, weights=pnight, sigma=77.26966)
plot(Dmarket)

pnight <- puntos_barrio$nightclub_dist
Dnight <- density(app, weights=pnight, sigma=77.26966)
plot(Dnight)

pnight <- puntos_barrio$police_dist
Dpolice <- density(app, weights=pnight, sigma=77.26966)
plot(Dpolice)


pnight <- puntos_barrio$pub_dist
Dpub <- density(app, weights=pnight, sigma=77.26966)
plot(Dpub)

pnight <- puntos_barrio$restaurant_dist
Drestaurant <- density(app, weights=pnight, sigma=77.26966)
plot(Drestaurant)


pnight <- puntos_barrio$taxi_dist
Dtaxi <- density(app, weights=pnight, sigma=77.26966)
plot(Dtaxi)

#QUITANDO VARIABLES
m1<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dindustrial+Dmarket+Dnight+Dpolice+Dpolice+Dpub+Drestaurant)
m2<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dindustrial+Dmarket+Dnight+Dpolice+Dpolice+Dpub)
m3<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dindustrial+Dmarket+Dnight+Dpolice)
m4<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dindustrial+Dmarket+Dnight)
m5<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dindustrial+Dmarket)
m6<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dindustrial)
m7<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe)
m8<-lppm(lpp_VALE ~ Datm+Dbank+Dbar)
m9<-lppm(lpp_VALE ~ Datm+Dbank)
m10<-lppm(lpp_VALE ~ Datm)
m11<-lppm(lpp_VALE ~ 1)


modelos<-list(m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11)

# Número de modelos
num_modelos <- length(modelos)

# Crear una matriz para almacenar los resultados del ANOVA
resultados_anova <- matrix(NA, nrow=num_modelos, ncol=num_modelos)
rownames(resultados_anova) <- colnames(resultados_anova) <- names(modelos)

# Realizar el ANOVA para cada par de modelos
for (i in 1:(num_modelos-1)) {
  for (j in (i+1):num_modelos) {
    m1 <- modelos[[i]]
    m2 <- modelos[[j]]
    resultado_anova <- anova(m1, m2)
    # Guardar el valor de devianza en la matriz
    resultados_anova[i, j] <- resultado_anova$Deviance[2]
  }
}

resultados_anova
res_AIC<-numeric(length(modelos))
k<-1
for(i in modelos){
  res_AIC[k]<-AIC(i)
  k<-k+1
}

res_AIC

# MODELOS elegidos al ojo 
#en base a m3 #AIC=21257.82
m3<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dindustrial+Dmarket+Dnight+Dpolice)

m12<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dmarket+Dnight+Dpolice)
AIC(m3)
AIC(m12)
anova.lppm(m3,m12,test ="LR")


m12<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dmarket+Dnight+Dpolice)
AIC(m3)
AIC(m12)
anova.lppm(m3,m12,test ="LR")

#NOS QUEDAMOS CON M3 POR AIC Y POR ANOVA.



lpp_VALEatm_distancia <- puntos_barrio$atm_dist
police_distancia <- puntos_barrio$police_dist
bar_distancia <- puntos_barrio$bar_dist

#atm_dist_imagen <- as.im(as.matrix(atm_distancia), W = Window(app))
#police_dist_imagen <- as.im(as.matrix(police_distancia), W = Window(app))
#bar_dist_imagen <- as.im(as.matrix(bar_distancia), W = Window(app))
#m1<-lppm(lpp_VALE ~ atm_dist_imagen+police_dist_imagen+bar_dist_imagen)
m1<-m3
r <- seq(0, 250, by=70)
k_finom<-linearKinhom(lpp_VALE,lambda = m3,r)
plot(k_finom)
```

```{r}
EIP <- predict(m1)
#plot(EIP)

 # Matern cluster process on a linear network
 # Centers = (x,y)-coordinates of parent points
 # R = The R parameter of the Matern cluster process
 # alpha = The alpha parameter of the Matern cluster process
 # LL = The linear network on which the point pattern should be simulated.
rMatClustlpp <- function(Centers, R, alpha, LL) {
X <- array(0,0)
Y <- array(0,0)
for(p in 1:length(Centers$data$x)) {
BBCOutD <- disc(radius=R, centre=c(Centers$data$x[p],
Centers$data$y[p]),
npoly = 32)
BBCD <- intersect.owin(LL$window, BBCOutD)
if(volume(LL[BBCOutD])>0) {
Xp <- rpoislpp(alpha/volume(LL[BBCOutD]), L=LL[BBCD])
X <- append(X, as.numeric(Xp$data$x))
Y <- append(Y, as.numeric(Xp$data$y))
}
}
lpp(cbind(X,Y), LL)
}
```


```{r warning=FALSE}
set.seed(2023)
Contrast <- array(0, c(length(valpha), length(vR)))
for(i in 1:length(valpha)) {
  for(j in 1:length(vR)) {
  # Compute the average K of 10 simulation from the model
  KMC <- array(0,length(r))
  for(s in 1:nsim) {
  # Centers from a Poisson process
  Centers <- rpoislpp(EIP/valpha[i], L=lpp_VALE[['domain']])
  XX <- rMatClustlpp(Centers, vR[j], valpha[i], lpp_VALE[['domain']])
  KMC <- KMC + linearKinhom(XX, lambda = m1, r=r)$est
  }
  # Compute the difference between estimated and average K
  Contrast[i,j] <- sqrt(sum((k_finom$est-KMC/nsim)^2))
  }
}

```

```{r}
 plot(as.im(Contrast), main="Values of Contrasts")
 # Finding the minimum value of the contrast
 id <- which(Contrast == min(Contrast), arr.ind = TRUE)
 alpha <- valpha[id[,1]]
 R <- vR[id[,2]]
 # Chosen values

```

```{r}
# Centers from a Poisson process
Centers <- rpoislpp(EIP/alpha, L=lpp_VALE[['domain']])
#par(mfrow=c(1,2))
plot(Centers)
XX <- rMatClustlpp(Centers, R, alpha, lpp_VALE[['domain']])
plot(XX, main="A realization of the model")
```


```{r}
y<-st_transform(y, crs = st_crs(puntos))
barrio<-st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
#plot(barrio)
a<-"151"
#y<-st_transform(y, crs = st_crs(puntos))
barrio<-st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
barrio<-barrio |> filter(coddistbar==a)
barrio<-st_transform(barrio, crs = st_crs(puntos))
interseccion<-st_intersection(y,barrio)
plot(interseccion)
puntos <- st_transform(puntos,st_crs(barrio))
puntos_barrio<-st_intersection(puntos,barrio)
plot(puntos_barrio)
calles_barrio<- interseccion[st_geometry_type(interseccion) == "LINESTRING", ]
```





```{r}
OrriolsST<-puntos_barrio |> mutate(crime_date=as.Date(crime_date,format = "%m/%d/%Y"))
stmyOrriolST<-OrriolsST |>mutate(anio_mes=format(crime_date,"%Y")) |> 
        group_by(anio_mes) |> summarise(Numero_de_Registros=n())

stmyOrriolST$Tiempo <-yearmonth(stmyOrriolST$anio_mes)
OrriolsST<-stmyOrriolST |>  as_tsibble(index = Tiempo) |> select(Tiempo,Numero_de_Registros)
OrriolsST %>%
  autoplot() +
  geom_point(color = "black") +  
  geom_line(color = "blue") +    # Establecer título
  theme_bw()


y<-st_transform(y, crs = st_crs(puntos))
barrio<-st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
#plot(barrio)
a<-"115"
#y<-st_transform(y, crs = st_crs(puntos))
barrio<-st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
barrio<-barrio |> filter(coddistbar==a)
barrio<-st_transform(barrio, crs = st_crs(puntos))
interseccion<-st_intersection(y,barrio)
plot(interseccion)
puntos <- st_transform(puntos,st_crs(barrio))
puntos_barrio<-st_intersection(puntos,barrio)
plot(puntos_barrio)
calles_barrio<- interseccion[st_geometry_type(interseccion) == "LINESTRING", ]

  
NazaretST<-puntos_barrio |> mutate(crime_date=as.Date(crime_date,format = "%m/%d/%Y"))
stmyNazaretST<-NazaretST |>mutate(anio_mes=format(crime_date,"%Y")) |> 
        group_by(anio_mes) |> summarise(Numero_de_Registros=n())

stmyNazaretST$Tiempo <-yearmonth(stmyNazaretST$anio_mes)
NazaretST<-stmyNazaretST |>  as_tsibble(index = Tiempo) |> select(Tiempo,Numero_de_Registros)
NazaretST%>%
  autoplot() +
  geom_point(color = "black") +  
  geom_line(color = "blue") +    # Establecer título
  theme_bw()


y<-st_transform(y, crs = st_crs(puntos))
barrio<-st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
#plot(barrio)
a<-"013"
#y<-st_transform(y, crs = st_crs(puntos))
barrio<-st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
barrio<-barrio |> filter(coddistbar==a)
barrio<-st_transform(barrio, crs = st_crs(puntos))
interseccion<-st_intersection(y,barrio)
plot(interseccion)
puntos <- st_transform(puntos,st_crs(barrio))
puntos_barrio<-st_intersection(puntos,barrio)
plot(puntos_barrio)
calles_barrio<- interseccion[st_geometry_type(interseccion) == "LINESTRING", ]
  
BenicalapST<-puntos_barrio |> mutate(crime_date=as.Date(crime_date,format = "%m/%d/%Y"))
stmyBenicalapST<-BenicalapST |>mutate(anio_mes=format(crime_date,"%Y")) |> 
        group_by(anio_mes) |> summarise(Numero_de_Registros=n())

stmyBenicalapST$Tiempo <-yearmonth(stmyBenicalapST$anio_mes)
BenicalapST<-stmyBenicalapST |>  as_tsibble(index = Tiempo) |> select(Tiempo,Numero_de_Registros)
BenicalapST %>%
  autoplot() +
  geom_point(color = "black") +  
  geom_line(color = "blue") +    # Establecer título
  theme_bw()
```

```{r}
ST <- add_column(ST, barrio = "Cabanyal")
OrriolsST<-add_column(OrriolsST,barrio="Orriols")
NazaretST<-add_column(NazaretST,barrio="Nazaret")
BenicalapST<-add_column(BenicalapST,barrio="El Carme")
OrriolsST <- as_tsibble(OrriolsST, key = barrio)
NazaretST <- as_tsibble(NazaretST, key = barrio)
BenicalapST<-as_tibble(BenicalapST,key=barrio)
ST <- as_tibble(ST, key=barrio )


```
```{r}
combined_ts <- bind_rows(OrriolsST, NazaretST,BenicalapST, ST)
combined_ts <-combined_ts|>mutate(Barrio=barrio) |> mutate(Barrio=ifelse(Barrio=="Cabanyal","El Cabanyal",Barrio)) 


ggplot(combined_ts, aes(x = Tiempo, y = Numero_de_Registros, color = Barrio)) +
  geom_line(size = 1.5) +  # Ajusta el grosor de las líneas
  geom_point(color = 'black') +  # Pone los puntos de observación en color negro
  labs(title = " ",
       x = "Tiempo",
       y = "Observaciones") +
  theme_light() +  # Cambia el tema a theme_light()
  theme(axis.text = element_text(face = "bold", size = 10),  # Texto de los ejes en negrita y más grande
        axis.title = element_text(face = "bold", size = 10),  # Títulos de los ejes en negrita y más grandes
        axis.title.x = element_text(margin = margin(t = 10)),  # Separa el título del eje X del propio eje
        axis.title.y = element_text(margin = margin(r = 10)),  # Separa el título del eje Y del propio eje
        legend.text = element_text(size = 10),  # Agranda los valores en la leyenda
        legend.title = element_text(size = 10))  # Agranda el título de la leyenda (si hay)
```

```{r}

tsibbledata::gafa_stock %>%
 autoplot(vars(Close, log(Close)))

```


#SIMULACIONES

```{r}
ventana<- st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
ventana<-ventana |> filter(coddistbar==112)
ventana1 <- st_transform(ventana, crs = st_crs("EPSG:32630"))
ventana2<-st_union(ventana1[1])
window<-st_coordinates(st_reverse(ventana2[1]))
a<-st_coordinates(st_reverse(ventana2[1]))
window<-owin(poly=a[,c("X","Y")])
plot(window)
window
vertices <- vertices.owin(window)


nueva_x <- vertices$x * 0.00005  # Reducir en un 50% en la dimensión x
nueva_y <- vertices$y * 0.00005  # Reducir en un 50% en la dimensión y

# Crear la nueva ventana
nueva_ventana <- owin(poly = cbind(nueva_x, nueva_y))
plot(nueva_ventana)
```


```{r}
# Definir el tamaño del cuadrado
#window <- ventana

kappa <- 700  # Intensidad del proceso de los puntos madre
mu <- 600   # Número medio de puntos hijo por punto madre
r <- 80 # Número medio de puntos por cluster

point_pattern <- rMatClust(kappa, r, mu, win=nueva_ventana)
plot(point_pattern)


quadrat.test(point_pattern,nx = 6,ny = 8)
plot(quadrat.test(point_pattern,nx = 6,ny = 8))

npoints(point_pattern)

```

```{r}

window <- owin(c(0, 1), c(0, 1))

# Parámetros iniciales del proceso de Matérn
kappa <- 10   # Intensidad del proceso de los puntos madre
mu <- 4       # Número medio de puntos hijo por punto madre
r <- 0.1      # Radio de dispersión de los puntos hijo

# Inicializar la variable para almacenar el número total de puntos
total_points <- 0

# Simular el proceso hasta que el número de puntos sea <= 50
while (total_points > 50 || total_points == 0) {
  matern_cluster <- rMatClust(kappa, r, mu, win=window)
  total_points <- matern_cluster$n
}

# Graficar el resultado
plot(matern_cluster, main=paste("Proceso Cluster de Matérn con", total_points, "puntos"))
```

```{r}
# Definir la ventana poligonal
vertices <- matrix(c(729140.7, 730337.6, 730337.6, 729140.7, 4371541, 4371541, 4373046, 4373046), ncol=2, byrow=TRUE)
window <- owin(poly=vertices)

# Inicializar los parámetros
kappa <- 10   # Intensidad del proceso de los puntos madre
mu <- 4       # Número medio de puntos hijo por punto madre
r <- 0.05     # Radio de dispersión de los puntos hijo

# Simular el proceso
matern_cluster <- rMatClust(kappa, r, mu, win=window)

# Contar el número de puntos dentro de la ventana
num_points <- nrow(as.data.frame(matern_cluster))

# Ajustar los parámetros si es necesario
while (num_points > 100) {
  # Disminuir la intensidad del proceso madre
  kappa <- kappa * 0.9
  
  # Volver a simular el proceso
  matern_cluster <- rMatClust(kappa, r, mu, win=window)
  
  # Contar el número de puntos dentro de la ventana
  num_points <- nrow(as.data.frame(matern_cluster))
}

# Graficar el resultado
plot(matern_cluster, main=paste("Proceso Cluster de Matérn con", num_points, "puntos"))
```
```{r}
# Definir la ventana (cuadrada de 1x1)
window <- owin(c(0, 1), c(0, 1))

# Parámetros iniciales del proceso de Matérn
kappa <- 15   # Intensidad del proceso de los puntos madre
mu <- 20      # Número medio de puntos hijo por punto madre
r <- 0.1      # Radio de dispersión de los puntos hijo

# Inicializar la variable para almacenar el número total de puntos
total_points <- 0



# Graficar el resultado
plot(matern_cluster, main=paste("Proceso Cluster de Matérn con", total_points, "puntos"))
```
```{r}
library(sp)
barrio_polygon <- Polygon(cbind(c(0, 0, 10, 10, 0), c(0, 10, 10, 0, 0)))
barrio_polygons <- Polygons(list(barrio_polygon), ID = "1")
barrio_sp <- SpatialPolygons(list(barrio_polygons))

# Generar puntos aleatorios dentro del polígono del barrio
n_points <- 100
random_points <- spsample(barrio_sp, n_points, type = "random")

# Simular el proceso de Matérn
smoothness <- 1.5
matern_process <- rMatern(n_points, scale = 1, smoothness = smoothness)
```

