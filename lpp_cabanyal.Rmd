---
title: "LPP_CABANYAL"
author: "Dario Quishpe"
date: "`r Sys.Date()`"
output: html_document
---


```{r}
library(tsibble)
library(tidyverse)
library(readxl)
library(sf)
library(leaflet)
library(deldir)
library(spatstat)
#install.packages("tigris")
library(tigris)
library(spatstat.geom)
library(spatstat.linnet)
#install.packages("spNetwork")
library(spNetwork)
library(sp)
library(maps)
library(stars)
library(terra)
#install.packages("sfnetworks")
library(sfnetworks)
#install.packages("PBSmapping")
library(PBSmapping)
library(tmap)
library(gridExtra)
library(grid)
library(jpeg)
#install.packages("raster")
library(raster)
pacman::p_load(tidyverse,sf,mapview)
```

```{r}
BASE<-read.csv("obs_data_112Valencia (1).csv", sep=",", header=TRUE)
dim(BASE)
BASE<-BASE |> filter(year<=2019) 
dim(BASE)
head(BASE)
```


```{r}
BASE<-read.csv("obs_data_112Valencia (1).csv", sep=",", header=TRUE) 
puntos<-BASE|>filter(year<=2019) |> 
  st_as_sf(coords=c("crime_lon","crime_lat"),crs= 4258)

#mapview(puntos, map.types = "CartoDB.Voyager")

puntos

ventana <- st_read("shape files-20221031T083303Z-001/shape files/valencia_outline.shp",quiet=TRUE)
y <- st_read("shape files-20221031T083303Z-001/shape files/valencia_road.shp",quiet=TRUE)
```


```{r}

y<-st_transform(y, crs = st_crs(puntos))
barrio<-st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
#plot(barrio)
a<-"112"
#y<-st_transform(y, crs = st_crs(puntos))
barrio<-st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
barrio<-barrio |> filter(coddistbar==a)
barrio<-st_transform(barrio, crs = st_crs(puntos))
interseccion<-st_intersection(y,barrio)
plot(interseccion)
puntos <- st_transform(puntos,st_crs(barrio))
puntos_barrio<-st_intersection(puntos,barrio)
plot(puntos_barrio)
calles_barrio<- interseccion[st_geometry_type(interseccion) == "LINESTRING", ]
view(barrio)
```



```{r}
puntos_grafica<-puntos_barrio 
dim(puntos_grafica)
dim(puntos)
ggplot() +
  geom_sf(data = ventana, color = "black", size = 0.2) +
  geom_sf(data = calles_barrio, color = "black") +
  geom_sf(data = puntos_grafica, aes(), size = 1.5, color = "red") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
        strip.background = element_rect(fill = "lightblue"),
        plot.margin = unit(c(0, 0, 0, 0), "cm"))


```



```{r}
st<-puntos_barrio |> mutate(crime_date=as.Date(crime_date,format = "%m/%d/%Y"))
stmy<-st |>mutate(anio_mes=format(crime_date,"%Y")) |> 
        group_by(anio_mes) |> summarise(Numero_de_Registros=n())

stmy$Tiempo <-yearmonth(stmy$anio_mes)
ST<-stmy |>  as_tsibble(index = Tiempo) |> select(Tiempo,Numero_de_Registros)
ST %>%
  autoplot() +
  geom_point(color = "black") +  
  geom_line(color = "blue") +    # Establecer título
  theme_bw()  
```

```{r}
diadelasemana<-puntos_barrio |> group_by(week_day_name) |> summarise(Observaciones=n()) |> arrange(Observaciones)
horadeldia<-puntos_barrio |> group_by(crime_hour) |> summarise(Observaciones=n()) |> arrange(crime_hour)

suma<-horadeldia |> filter(crime_hour>=18| crime_hour<=1)
sum(suma$Observaciones)
sum(horadeldia$Observaciones)
diadelasemana$week_day_name <- factor(diadelasemana$week_day_name, levels = c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"),
                              labels = c("Lun", "Mar", "Miér", "Jue", "Vier", "Sáb", "Dom"))

color_palette <- colorRampPalette(c("yellow", "orange","red"))

dias<-ggplot(diadelasemana, aes(x = week_day_name, y = Observaciones, fill = Observaciones)) +
  geom_bar(stat = "identity") +geom_text(aes(label = Observaciones), vjust = -0, color = "black", size = 3)+
  scale_fill_gradientn(colours = color_palette(nrow(diadelasemana))) + 
  labs(x = "Día de la semana", y = "Observaciones") +
  scale_x_discrete(labels = function(x) gsub("Tuesday", "Mar", gsub("Monday", "Lun", gsub("Wednesday", "Miér", gsub("Thursday", "Jue", gsub("Friday", "Vier", gsub("Saturday", "Sáb", gsub("Sunday", "Dom", x)))))))) +
  theme_minimal() +theme(plot.margin = margin(5, 0, 0, 0, "mm"),
        panel.spacing = unit(10, "lines"))+
  theme(axis.text.x = element_text(angle = 360, hjust = 1)) 

horas<-ggplot(horadeldia, aes(x = crime_hour, y = Observaciones, fill = Observaciones)) +
  geom_bar(stat = "identity") +geom_text(aes(label = Observaciones), vjust = -0.05, color = "black", size = 3, angle = 90, position = position_stack(vjust = 0.9))+
  scale_fill_gradientn(colours = color_palette(nrow(horadeldia))) + 
  labs(x = "Hora del día", y = "Observaciones") +theme(plot.margin = margin(2, 2, 2, 2, "mm"),
        panel.spacing = unit(0, "lines"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 0, hjust = 1)) 

grid.arrange(dias,horas)

```



```{r}
tm_shape(calles_barrio) + 
  tm_lines("black") + 
  tm_shape(puntos_barrio) + 
  tm_dots(col = "blue", size = 0.2)
```


```{r}
ventana<- st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
ventana<-ventana |> filter(coddistbar==a)
ventana1 <- st_transform(ventana, crs = st_crs("EPSG:32630"))
ventana2<-st_union(ventana1[1])
window<-st_coordinates(st_reverse(ventana2[1]))
a<-st_coordinates(st_reverse(ventana2[1]))
window<-owin(poly=a[,c("X","Y")])
plot(window)



target_crs <- st_crs("+proj=utm +zone=30 +north +datum=WGS84 +units=m +no_defs")
a_sf_reprojected <- st_transform(puntos, target_crs)

app <- ppp( x = st_coordinates(a_sf_reprojected)[,1],
            y = st_coordinates(a_sf_reprojected)[,2],
            marks = c(1:3221),
            window = window)

plot(app)

#app<-rjitter(app, retry = TRUE, nsim = 1, drop = TRUE)

unique(app)
unique(app, rule="deldir")
options(repr.plot.width = 50, repr.plot.height = 30)
plot(quadratcount(app, nx = 13, ny = 8))
quadrat.test(app, nx = 13, ny = 8)
```
```{r}
grid <- ventana%>%
  st_make_grid(n = c(13,8)) %>%
  st_intersection(ventana) %>% 
   st_cast("MULTIPOLYGON") %>%
  st_sf()
plot(grid)
puntos_barrio <- st_transform(puntos_barrio, crs = st_crs(grid))

inter <- st_intersects(grid, puntos_barrio)
grid$count <- lengths(inter)
ggplot(grid) + geom_sf(aes(fill = count))


ggplot(grid) + geom_sf(aes(fill = count))+
scale_fill_continuous(type = "viridis")



grid.selec <- grid
# Crear el gráfico
grilla <- ggplot(grid.selec) + 
  geom_sf(aes(fill = count)) +
  geom_sf_text(aes(label = count), size = 3, color = "white") +  # Ajusta el tamaño aquí
  scale_fill_continuous(type = "viridis") +
  theme(
    axis.text = element_text(size = 12, face = "bold"),  # Agrega negrita aquí
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)
  ) +
  theme(
    plot.margin = margin(2, 2, 2, 2, "mm"),
    panel.spacing = unit(0, "lines")
  )

# Mostrar el gráfico
grilla
```


```{r}

#Estimaciones de sigma 
estimacion1<-bw.diggle(app)
estimacion2<-bw.ppl(app)
estimacion3<-bw.scott(app)
plot(density.ppp(app,sigma = estimacion1,edge = T),main=paste("Diggle"))
plot(density.ppp(app,sigma = estimacion2,edge = T),main=paste("LH-crossvalidation"))
plot(density.ppp(app,sigma = estimacion3[1],edge = T),main=paste(""))
plot(density.ppp(app,sigma = estimacion3[2],edge = T),main=paste("Scott2"))
estimacion1
estimacion2
estimacion3[1]
estimacion3[2]

```


```{r}

# Ajustar el layout para 2 filas y 2 columnas y reducir márgenes
par(mfrow = c(2, 2), mar = c(0, 0, 0, 0), oma = c(0, 0, 0, 0), mai = c(0, 0, 0.2, 0))

# Graficar cada densidad en su respectivo lugar
plot(density.ppp(app, sigma = 0.5, edge = TRUE), main = "Ancho de Banda: 0.5")
plot(density.ppp(app, sigma = 15, edge = TRUE), main = "Ancho de Banda: 15")
plot(density.ppp(app, sigma = 55, edge = TRUE), main = "Ancho de Banda: 55")
plot(density.ppp(app, sigma = 120, edge = TRUE), main = "Ancho de Banda: 120")


```

```{r}
K_function <- Kest(app)
summary(K_function)
plot(K_function, main = "Función K(r)")
K_functioninom <- Kinhom(app,r = seq(0,180,by=10))
summary(K_functioninom)
plot(K_functioninom, main = "Función K(r) no homogéneo")
plot(Gest(app))
```

```{r}
# Graficar la red vial con ggplot2
# Extraer las líneas y los nodos
par(mar = c(2.5,2.5,1,1))
plot(red_vial_ln, col = '#017308', pch = 18, lwd = 1, cex = 2,graticule = TRUE, axes = TRUE)
```



```{r}
#ANALISIS SOLO CON M1 DEPENDIENTE DE LA POSICION 
#auxiliar<-st_union(calles_distrito1)
#plot(auxiliar)
red_vial_ln<- as_sfnetwork(calles_barrio)
plot(red_vial_ln)
calles_barrio <- st_transform(calles_barrio, crs = "+proj=utm +zone=30 +datum=WGS84")
puntos_barrio <- st_transform(puntos_barrio, crs = "+proj=utm +zone=30 +datum=WGS84")
red_vial_ln <- st_transform(red_vial_ln, crs = "+proj=utm +zone=30 +datum=WGS84")
red_vial_ln <- as.linnet(red_vial_ln)
lpp_VALE <- lpp(app,red_vial_ln)
#plot(lpp_VALE)
#lambdahat <- density.lpp(lpp_VALE,sigma = 150,distance = "euclidean",continuous = TRUE,kernel = "gaussian" )
#plot(lambdahat)

lambda <- density.lpp(lpp_VALE,sigma = 77.26966 ,distance = "euclidean")
par(mfrow = c(1, 1), mar = c(0, 0, 2, 0), oma = c(0, 0, 0, 0))
plot(lambda,main="Ancho de Banda: 77.27")
lpp_VALE<-unmark(lpp_VALE)
m1<-lppm(lpp_VALE ~ 1)
r <- seq(0, 300, by=50)
k_finom<-linearKinhom(lpp_VALE,lambda = m1,r)
plot(k_finom,main="Función K no homogénea")
plot(lpp_VALE, pch=19,main=" ",cex = 1.2,cols = "red")
plot(red_vial_ln)
```
```{r}

plot(lpp_VALE, col = '#FFC278', pch = 16, lwd = 1, cex = 1,graticule = TRUE, axes = TRUE)
```



```{r}

EIP <- predict(m3)
#plot(EIP)

 # Matern cluster process on a linear network
 # Centers = (x,y)-coordinates of parent points
 # R = The R parameter of the Matern cluster process
 # alpha = The alpha parameter of the Matern cluster process
 # LL = The linear network on which the point pattern should be simulated.
rMatClustlpp <- function(Centers, R, alpha, LL) {
X <- array(0,0)
Y <- array(0,0)
for(p in 1:length(Centers$data$x)) {
  BBCOutD <- disc(radius=R, centre=c(Centers$data$x[p],
  Centers$data$y[p]),npoly = 32)
  BBCD <- intersect.owin(LL$window, BBCOutD)
  if(volume(LL[BBCOutD])>0) {
    Xp <- rpoislpp(alpha/volume(LL[BBCOutD]), L=LL[BBCD])
    X <- append(X, as.numeric(Xp$data$x))
    Y <- append(Y, as.numeric(Xp$data$y))
    }
  }
lpp(cbind(X,Y), LL)
}
```



```{r}
r <- seq(0, 300, by=50)
nsim <- 5
valpha <- seq(5, 100, by=20)
vR <- seq(50, 800, by=100)
k_finom<-linearKinhom(lpp_VALE,lambda = m3,r)
plot(k_finom)
```


```{r}
set.seed(2024)
Contrast <- array(0, c(length(valpha), length(vR)))
for(i in 1:length(valpha)) {
  for(j in 1:length(vR)) {
  # Compute the average K of 10 simulation from the model
  KMC <- array(0,length(r))
  for(s in 1:nsim) {
  # Centers from a Poisson process
  Centers <- rpoislpp(EIP/valpha[i], L=lpp_VALE[['domain']])
  XX <- rMatClustlpp(Centers, vR[j], valpha[i], lpp_VALE[['domain']])
  KMC <- KMC + linearKinhom(XX, lambda = m3, r=r)$est
  }
  # Compute the difference between estimated and average K
  Contrast[i,j] <- sqrt(sum((k_finom$est-KMC/nsim)^2))
  }
}

```


```{r}
#save(Contrast, file="Contrastes.Rdata")
load(file = "Contrastes.Rdata")
```


```{r fig.height=3, fig.width=5}
par(mar = c(1, 1, 1, 1.5) )  # Ajusta los márgenes (bottom, left, top, right)
par(mgp = c(0, 1, 1))  # Ajusta los márgenes para title, axis label, and axis numbers
plot(as.im(Contrast), main="Valores de contraste",cex.main = 0.8)

```

```{r}
 plot(as.im(Contrast), main="Valores de contraste")
 # Finding the minimum value of the contrast
 id <- which(Contrast == min(Contrast), arr.ind = TRUE)
 alpha <- valpha[id[,1]]
 R <- vR[id[,2]]
 # Chosen values
R
alpha
plot(x=r,KMC,type="l")
```


```{r}
set.seed(2024)
# Centers from a Poisson process
Centers <- rpoislpp(EIP/alpha, L=lpp_VALE[['domain']])

plot(Centers)
plot(Centers, col = 'red', pch = 16, lwd = 1, cex = 1,graticule = TRUE, axes = TRUE)
XX <- rMatClustlpp(Centers, R, alpha, lpp_VALE[['domain']])
#plot(XX, main="Una realización del modelo")
plot(XX, pch=19,main="Realización del proceso",cex = 0.5,cols = "red")
lambda_modelo <- density.lpp(XX,sigma = 70 ,distance = "euclidean")
plot(lambda_modelo)
m_modelo<-lppm(XX ~ 1)
r <- seq(0, 300, by=50)
k_finom_modelo<-linearKinhom(XX,lambda = m_modelo,r)
plot(k_finom_modelo)
print(Centers)
```
```{r}
m1<-lppm(lpp_VALE ~ 1)
r <- seq(0, 300, by=50)
k_finom<-linearKinhom(lpp_VALE,lambda = m1,r)
m_modelo<-lppm(XX ~ 1)
r <- seq(0, 300, by=50)
k_finom_modelo<-linearKinhom(XX,lambda = m_modelo,r)
plot(k_finom,main="Función K no homogénea")
KMC_promedios<-KMC/c(1,1,2,3,4,5,6)
lines(r, KMC_promedios, col = "red", lwd = 2)

```


```{r fig.height=5, fig.width=7}
par(mar = c(1, 1, 1, 1.5) )  # Ajusta los márgenes (bottom, left, top, right)
par(mgp = c(0, 1, 1))
plot(XX, pch=19,main=" ",cex = 0.5,cols = "red")
```


```{r fig.height=5, fig.width=7}
# Graficar el patrón de puntos en la red lineal
plot(lambda_modelo)
plot(Centers, main=" ",
     sub="34 puntos, 368 vértices, 291 líneas",
     lwd=2, col="grey", cex.main=1.5, cex.sub=1.2,graticule = TRUE, axes = TRUE)

# Añadir los puntos en la red
plot(Centers, add=TRUE, cols="red", pch=19, cex=1.5)
```

```{r}
par(mar = c(1, 1, 1, 2) )  # Ajusta los márgenes (bottom, left, top, right)
par(mgp = c(2, 1, 1))
par(cex.axis = 1) 
# Graficar el patrón de puntos en la red lineal
plot(lambda_modelo,main="",graticule ,lwd=2, cex.main=1, cex.sub=1)
#points(Centers, main=" ",
#     sub="34 puntos, 368 vértices, 291 líneas",
#     lwd=2, col="grey", cex.main=1.5, cex.sub=1.2)

# Añadir los puntos en la red
points(Centers, pch=19, cex=1.5)
```

```{r}

par(mar = c(1, 1, 1, 2) )  # Ajusta los márgenes (bottom, left, top, right)
par(mgp = c(2, 1, 1))
par(cex.axis = 1) 
# Graficar el patrón de puntos en la red lineal
plot(lambda,main="",graticule ,lwd=2, cex.main=1, cex.sub=1)
#points(Centers, main=" ",
#     sub="34 puntos, 368 vértices, 291 líneas",
#     lwd=2, col="grey", cex.main=1.5, cex.sub=1.2)

# Añadir los puntos en la red
points(Centers, pch=19, cex=1.5)
```


```{r}
set.seed(2024)
nsim <- 1000
 sims.densi <- vector(mode = "list", length = nsim)
for(s in 1:nsim) {
  CentersFDR <- rpoislpp(EIP/alpha, L=lpp_VALE[['domain']])
  simss <- rMatClustlpp(CentersFDR, R, alpha, lpp_VALE[['domain']])
  sims.densi[[s]] <- density.lpp(simss, sigma = 77, distance="euclidean")
}
```

```{r}
library(GET)
 yx <- expand.grid(lambda$yrow, lambda$xcol)
 noNA_id <- which(!is.na(lambda$v))
 noNA_idsim <- which(!is.na(sims.densi[[1]]$v))
 noNA_id <- intersect(noNA_id, noNA_idsim)
 #max(densi[noNA_id]); summary(sapply(sims.densi, FUN=max))

cset <- create_curve_set(list(
r=data.frame(x=yx[,2], y=yx[,1],
width=lambda$xstep, height=lambda$ystep)[noNA_id,],
obs=as.vector(lambda$v)[noNA_id],
sim_m=sapply(sims.densi, FUN=function(x){ as.vector(x$v)[noNA_id] },
simplify=TRUE)))
save(cset, file="crimenes_cset.Rdata")
cset
```
```{r}
set.seed(2024)
plot(cset, idx=10, main="The observed intensity")

```

```{r}
set.seed(2024)
res <- fdr_envelope(cset,alternative = "greater",alpha = 0.20)
res

plot(res)+scale_radius(range = 0.5 * c(1, 10))

```


```{r}
# Define el radio en metros (suponiendo que tus datos están en un sistema de coordenadas específico)
radio_metros <- 350

# Convertir radio de metros a las unidades de coordenadas (si es necesario)
# Esto depende de la proyección de tus datos; si estás trabajando en un sistema de coordenadas lineales, esto es directo.
radio_coordenadas <- radio_metros

# Dibuja el patrón de puntos en una red lineal
plot(Centers, main="Patrón de puntos en una red lineal",
     sub="34 puntos, 368 vértices, 291 líneas",
     lwd=2, col="grey", cex.main=1.5, cex.sub=1.2, graticule=TRUE, axes=TRUE)

# Añade los puntos en la red
points(Centers, col="red", pch=19, cex=1.5)

# Dibuja círculos alrededor de cada punto sin rellenarlos
symbols(Centers$data$x, Centers$data$y, circles=rep(radio_coordenadas, nrow(Centers$data)), inches=FALSE, add=TRUE, bg="transparent", fg="blue", lwd=2)

```
```{r}
# Suponiendo que ya tienes definidos tus datos de Centros y estás en un sistema de coordenadas específico

# Define el radio en metros
radio_metros <- 450

# Dibuja el patrón de puntos en una red lineal
plot(Centers, main = "Patrón de puntos en una red lineal",
     sub = "34 puntos, 368 vértices, 291 líneas",
     lwd = 2, col = "grey", cex.main = 1.5, cex.sub = 1.2, graticule = TRUE, axes = TRUE)

# Añade los puntos en la red
points(Centers, col = "red", pch = 19, cex = 1.5)

# Dibuja círculos alrededor de cada punto sin rellenarlos
symbols(Centers$data$x, Centers$data$y, circles = rep(radio_metros, nrow(Centers$data)), inches = FALSE, add = TRUE, bg = "transparent", fg = "blue", lwd = 2)
```


```{r}
#ANALISIS CON COVARIABLES
## CREANDO VARIABLES

#par(mfrow = c(4,3), mar = c(0, 0, 1, 0), oma = c(0, 0, 0, 0))
# Ajustar el layout para 2 filas y 2 columnas y reducir márgenes
par(mfrow = c(4, 3), mar = c(0, 0, 0, 0), oma = c(0, 0, 0, 0), mai = c(0, 0, 0.2, 0))
pnight <- puntos_barrio$atm_dist
Datm <- density(app, weights=pnight, sigma=77.26966)
plot(Datm,main="Atm (Datm)")

pnight <- puntos_barrio$bank_dist
Dbank <- density(app, weights=pnight, sigma=77.26966)
plot(Dbank,main="Banco (Dbank)")

pnight <- puntos_barrio$bar_dist
Dbar <- density(app, weights=pnight, sigma=77.26966)
plot(Dbar,main="Bar (Dbar)")

pnight <- puntos_barrio$cafe_dist
Dcafe <- density(app, weights=pnight, sigma=77.26966)
plot(Dcafe,main="Cafetería (Dcafe)")

pnight <- puntos_barrio$industrial_dist
Dindustrial <- density(app, weights=pnight, sigma=77.26966)
plot(Dindustrial,main="Zona Industrial (Dindustrial)")

pnight <- puntos_barrio$market_dist
Dmarket <- density(app, weights=pnight, sigma=77.26966)
plot(Dmarket,main="Mercado(Dmarket)")

pnight <- puntos_barrio$nightclub_dist
Dnight <- density(app, weights=pnight, sigma=77.26966)
plot(Dnight,main="Nightclub (Dnight)")

pnight <- puntos_barrio$police_dist
Dpolice <- density(app, weights=pnight, sigma=77.26966)
plot(Dpolice,main="Dep Policia (Dpolice)")


pnight <- puntos_barrio$pub_dist
Dpub <- density(app, weights=pnight, sigma=77.26966)
plot(Dpub,main="Pub (Dpub)")

pnight <- puntos_barrio$restaurant_dist
Drestaurant <- density(app, weights=pnight, sigma=77.26966)
plot(Drestaurant,main="Restaurante (Drestaurant)")


pnight <- puntos_barrio$taxi_dist
Dtaxi <- density(app, weights=pnight, sigma=77.26966)
plot(Dtaxi,main="Estacionamiento Taxis (Dtaxi)")

#QUITANDO VARIABLES
m1<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dindustrial+Dmarket+Dnight+Dpolice+Dpolice+Dpub+Drestaurant)
m2<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dindustrial+Dmarket+Dnight+Dpolice+Dpolice+Dpub)
m3<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dindustrial+Dmarket+Dnight+Dpolice)
m4<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dindustrial+Dmarket+Dnight)
m5<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dindustrial+Dmarket)
m6<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dindustrial)
m7<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe)
m8<-lppm(lpp_VALE ~ Datm+Dbank+Dbar)
m9<-lppm(lpp_VALE ~ Datm+Dbank)
m10<-lppm(lpp_VALE ~ Datm)
m11<-lppm(lpp_VALE ~ 1)
#modelo_profe<-ppm(unmark(app)~taxi_dist,data=puntos_barrio)

modelos<-list(m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11)

# Número de modelos
num_modelos <- length(modelos)

# Crear una matriz para almacenar los resultados del ANOVA
resultados_anova <- matrix(NA, nrow=num_modelos, ncol=num_modelos)
rownames(resultados_anova) <- colnames(resultados_anova) <- names(modelos)

# Realizar el ANOVA para cada par de modelos
for (i in 1:(num_modelos-1)) {
  for (j in (i+1):num_modelos) {
    m1 <- modelos[[i]]
    m2 <- modelos[[j]]
    resultado_anova <- anova(m1, m2)
    # Guardar el valor de devianza en la matriz
    resultados_anova[i, j] <- resultado_anova$Deviance[2]
  }
}

resultados_anova
res_AIC<-numeric(length(modelos))
k<-1
for(i in modelos){
  res_AIC[k]<-AIC(i)
  k<-k+1
}

res_AIC

# MODELOS elegidos al ojo 
#en base a m3 #AIC=21257.82
m3<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dindustrial+Dmarket+Dnight+Dpolice)

m12<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dmarket+Dnight+Dpolice)
AIC(m3)
AIC(m12)
anova.lppm(m3,m12,test ="LR")


m12<-lppm(lpp_VALE ~ Datm+Dbank+Dbar+Dcafe+Dmarket+Dnight+Dpolice)
AIC(m3)
AIC(m12)
anova.lppm(m3,m12,test ="LR")

#NOS QUEDAMOS CON M3 POR AIC Y POR ANOVA.



lpp_VALEatm_distancia <- puntos_barrio$atm_dist
police_distancia <- puntos_barrio$police_dist
bar_distancia <- puntos_barrio$bar_dist

#atm_dist_imagen <- as.im(as.matrix(atm_distancia), W = Window(app))
#police_dist_imagen <- as.im(as.matrix(police_distancia), W = Window(app))
#bar_dist_imagen <- as.im(as.matrix(bar_distancia), W = Window(app))
#m1<-lppm(lpp_VALE ~ atm_dist_imagen+police_dist_imagen+bar_dist_imagen)
m1<-m3
r <- seq(0, 250, by=70)
k_finom<-linearKinhom(lpp_VALE,lambda = m3,r)
envelope(m3)

plot(k_finom)
```
```{r}
par(mfrow = c(1, 1), mar = c(0, 0, 2, 0), oma = c(0, 0, 0, 0))
plot(predict(m3),main=" ")
m3
```

```{r}
EIP <- predict(m1)
#plot(EIP)

 # Matern cluster process on a linear network
 # Centers = (x,y)-coordinates of parent points
 # R = The R parameter of the Matern cluster process
 # alpha = The alpha parameter of the Matern cluster process
 # LL = The linear network on which the point pattern should be simulated.
rMatClustlpp <- function(Centers, R, alpha, LL) {
X <- array(0,0)
Y <- array(0,0)
for(p in 1:length(Centers$data$x)) {
BBCOutD <- disc(radius=R, centre=c(Centers$data$x[p],
Centers$data$y[p]),
npoly = 32)
BBCD <- intersect.owin(LL$window, BBCOutD)
if(volume(LL[BBCOutD])>0) {
Xp <- rpoislpp(alpha/volume(LL[BBCOutD]), L=LL[BBCD])
X <- append(X, as.numeric(Xp$data$x))
Y <- append(Y, as.numeric(Xp$data$y))
}
}
lpp(cbind(X,Y), LL)
}
```


```{r warning=FALSE}
set.seed(2023)
Contrast <- array(0, c(length(valpha), length(vR)))
for(i in 1:length(valpha)) {
  for(j in 1:length(vR)) {
  # Compute the average K of 10 simulation from the model
  KMC <- array(0,length(r))
  for(s in 1:nsim) {
  # Centers from a Poisson process
  Centers <- rpoislpp(EIP/valpha[i], L=lpp_VALE[['domain']])
  XX <- rMatClustlpp(Centers, vR[j], valpha[i], lpp_VALE[['domain']])
  KMC <- KMC + linearKinhom(XX, lambda = m1, r=r)$est
  }
  # Compute the difference between estimated and average K
  Contrast[i,j] <- sqrt(sum((k_finom$est-KMC/nsim)^2))
  }
}

```

```{r}
 plot(as.im(Contrast), main="Values of Contrasts")
 # Finding the minimum value of the contrast
 id <- which(Contrast == min(Contrast), arr.ind = TRUE)
 alpha <- valpha[id[,1]]
 R <- vR[id[,2]]
 # Chosen values

```

```{r}
# Centers from a Poisson process
Centers <- rpoislpp(EIP/alpha, L=lpp_VALE[['domain']])
#par(mfrow=c(1,2))
plot(Centers)
XX <- rMatClustlpp(Centers, R, alpha, lpp_VALE[['domain']])
plot(XX, main="A realization of the model")
```


```{r}
y<-st_transform(y, crs = st_crs(puntos))
barrio<-st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
#plot(barrio)
a<-"151"
#y<-st_transform(y, crs = st_crs(puntos))
barrio<-st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
barrio<-barrio |> filter(coddistbar==a)
barrio<-st_transform(barrio, crs = st_crs(puntos))
interseccion<-st_intersection(y,barrio)
plot(interseccion)
puntos <- st_transform(puntos,st_crs(barrio))
puntos_barrio<-st_intersection(puntos,barrio)
plot(puntos_barrio)
calles_barrio<- interseccion[st_geometry_type(interseccion) == "LINESTRING", ]
```





```{r}
OrriolsST<-puntos_barrio |> mutate(crime_date=as.Date(crime_date,format = "%m/%d/%Y"))
stmyOrriolST<-OrriolsST |>mutate(anio_mes=format(crime_date,"%Y")) |> 
        group_by(anio_mes) |> summarise(Numero_de_Registros=n())

stmyOrriolST$Tiempo <-yearmonth(stmyOrriolST$anio_mes)
OrriolsST<-stmyOrriolST |>  as_tsibble(index = Tiempo) |> select(Tiempo,Numero_de_Registros)
OrriolsST %>%
  autoplot() +
  geom_point(color = "black") +  
  geom_line(color = "blue") +    # Establecer título
  theme_bw()


y<-st_transform(y, crs = st_crs(puntos))
barrio<-st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
#plot(barrio)
a<-"115"
#y<-st_transform(y, crs = st_crs(puntos))
barrio<-st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
barrio<-barrio |> filter(coddistbar==a)
barrio<-st_transform(barrio, crs = st_crs(puntos))
interseccion<-st_intersection(y,barrio)
plot(interseccion)
puntos <- st_transform(puntos,st_crs(barrio))
puntos_barrio<-st_intersection(puntos,barrio)
plot(puntos_barrio)
calles_barrio<- interseccion[st_geometry_type(interseccion) == "LINESTRING", ]

  
NazaretST<-puntos_barrio |> mutate(crime_date=as.Date(crime_date,format = "%m/%d/%Y"))
stmyNazaretST<-NazaretST |>mutate(anio_mes=format(crime_date,"%Y")) |> 
        group_by(anio_mes) |> summarise(Numero_de_Registros=n())

stmyNazaretST$Tiempo <-yearmonth(stmyNazaretST$anio_mes)
NazaretST<-stmyNazaretST |>  as_tsibble(index = Tiempo) |> select(Tiempo,Numero_de_Registros)
NazaretST%>%
  autoplot() +
  geom_point(color = "black") +  
  geom_line(color = "blue") +    # Establecer título
  theme_bw()


y<-st_transform(y, crs = st_crs(puntos))
barrio<-st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
#plot(barrio)
a<-"013"
#y<-st_transform(y, crs = st_crs(puntos))
barrio<-st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
barrio<-barrio |> filter(coddistbar==a)
barrio<-st_transform(barrio, crs = st_crs(puntos))
interseccion<-st_intersection(y,barrio)
plot(interseccion)
puntos <- st_transform(puntos,st_crs(barrio))
puntos_barrio<-st_intersection(puntos,barrio)
plot(puntos_barrio)
calles_barrio<- interseccion[st_geometry_type(interseccion) == "LINESTRING", ]
  
BenicalapST<-puntos_barrio |> mutate(crime_date=as.Date(crime_date,format = "%m/%d/%Y"))
stmyBenicalapST<-BenicalapST |>mutate(anio_mes=format(crime_date,"%Y")) |> 
        group_by(anio_mes) |> summarise(Numero_de_Registros=n())

stmyBenicalapST$Tiempo <-yearmonth(stmyBenicalapST$anio_mes)
BenicalapST<-stmyBenicalapST |>  as_tsibble(index = Tiempo) |> select(Tiempo,Numero_de_Registros)
BenicalapST %>%
  autoplot() +
  geom_point(color = "black") +  
  geom_line(color = "blue") +    # Establecer título
  theme_bw()
```

```{r}
ST <- add_column(ST, barrio = "Cabanyal")
OrriolsST<-add_column(OrriolsST,barrio="Orriols")
NazaretST<-add_column(NazaretST,barrio="Nazaret")
BenicalapST<-add_column(BenicalapST,barrio="El Carme")
OrriolsST <- as_tsibble(OrriolsST, key = barrio)
NazaretST <- as_tsibble(NazaretST, key = barrio)
BenicalapST<-as_tibble(BenicalapST,key=barrio)
ST <- as_tibble(ST, key=barrio )


```
```{r}
combined_ts <- bind_rows(OrriolsST, NazaretST,BenicalapST, ST)
combined_ts <-combined_ts|>mutate(Barrio=barrio) |> mutate(Barrio=ifelse(Barrio=="Cabanyal","El Cabanyal",Barrio)) 


ggplot(combined_ts, aes(x = Tiempo, y = Numero_de_Registros, color = Barrio)) +
  geom_line(size = 1.5) +  # Ajusta el grosor de las líneas
  geom_point(color = 'black') +  # Pone los puntos de observación en color negro
  labs(title = " ",
       x = "Tiempo",
       y = "Observaciones") +
  theme_light() +  # Cambia el tema a theme_light()
  theme(axis.text = element_text(face = "bold", size = 10),  # Texto de los ejes en negrita y más grande
        axis.title = element_text(face = "bold", size = 10),  # Títulos de los ejes en negrita y más grandes
        axis.title.x = element_text(margin = margin(t = 10)),  # Separa el título del eje X del propio eje
        axis.title.y = element_text(margin = margin(r = 10)),  # Separa el título del eje Y del propio eje
        legend.text = element_text(size = 10),  # Agranda los valores en la leyenda
        legend.title = element_text(size = 10))  # Agranda el título de la leyenda (si hay)
```

```{r}

tsibbledata::gafa_stock %>%
 autoplot(vars(Close, log(Close)))

```


#SIMULACIONES

```{r}
ventana<- st_read("barris-barrios/barris-barrios.shp",quiet=TRUE)
ventana<-ventana |> filter(coddistbar==112)
ventana1 <- st_transform(ventana, crs = st_crs("EPSG:32630"))
ventana2<-st_union(ventana1[1])
window<-st_coordinates(st_reverse(ventana2[1]))
a<-st_coordinates(st_reverse(ventana2[1]))
window<-owin(poly=a[,c("X","Y")])
plot(window)
window
vertices <- vertices.owin(window)


nueva_x <- vertices$x * 0.000005  
nueva_y <- vertices$y * 0.000005  

# Crear la nueva ventana
nueva_ventana <- owin(poly = cbind(nueva_x, nueva_y))
plot(nueva_ventana)
```


```{r}
# Definir el tamaño del cuadrado
#window <- ventana

kappa <- 1000000   # Tasa de padres (puntos de base Poisson)
r <- 0.001      # Radio de los clusters
mu <- 10        # Número medio de puntos secundarios por cluster

plot(nueva_ventana)
point_pattern <- rMatClust(kappa, r, mu, win=nueva_ventana,)
plot(point_pattern)


quadrat.test(point_pattern,nx = 6,ny = 8)
plot(quadrat.test(point_pattern,nx = 6,ny = 8))

npoints(point_pattern)

```


```{r}
library(spatstat)
set.seed(10)
# Parámetros
lambda_parents <- 20  # Intensidad del proceso Poisson de los padres
mu_offspring <- 10    # Media de la cantidad de hijos por padre
R <- 0.1              # Radio del círculo alrededor del padre
par(mfrow = c(1, 3), mar=c(5, 4, 1, 1), oma=c(5, 5, 5, 5))  # Ajustar los márgenes internos y externos
# 1. Generar puntos padres (proceso Poisson homogéneo)
parents <- rpoispp(lambda_parents, win=owin(c(0, 1), c(0, 2)))
plot(parents, main="Puntos Padres", pch=19, cols = "blue")

# 2. Generar puntos hijos alrededor de cada padre y dibujar los círculos
offspring <- NULL
plot(parents, main="Discos de radio R", pch=16, xlab="", ylab="", asp=1, cols = "blue")
for (i in 1:parents$n) {
  num_offspring <- rpois(1, mu_offspring)
  if (num_offspring > 0) {
    angles <- runif(num_offspring, 0, 2 * pi)
    radii <- R * sqrt(runif(num_offspring))
    xoffs <- parents$x[i] + radii * cos(angles)
    yoffs <- parents$y[i] + radii * sin(angles)
    offspring <- rbind(offspring, data.frame(x = xoffs, y = yoffs))
  }
  # Dibujar los círculos
  symbols(parents$x[i], parents$y[i], circles = R, add = TRUE, inches = FALSE, fg = "red")
}

# 3. Dibujar sólo los puntos hijos dentro de los círculos, sin los puntos padres
offspring_points <- ppp(offspring$x, offspring$y, window = owin(c(0, 1), c(0, 2)))
plot(offspring_points, main="Proceso cluster de Matérn", pch=16, xlab="", ylab="", asp=1)
for (i in 1:parents$n) {
  symbols(parents$x[i], parents$y[i], circles = R, add = TRUE, inches = FALSE, fg = "red")
}


```

```{r}
win <- owin(c(0, 1), c(0, 2))

offspring_points

#unique(offspring_points)
#unique(offspring_points, rule="deldir")

#options(repr.plot.width = 50, repr.plot.height = 30)
plot(quadratcount(offspring_points, nx = 8, ny = 8))
quadrat.test(offspring_points, nx = 8, ny = 8)
offspring_points

```



```{r}

# Realizar el conteo por cuadrantes
quadrant_count <- quadratcount(offspring_points, nx = 8, ny = 8)

# Obtener los valores del conteo para asignar colores
count_values <- as.vector(as.matrix(quadrant_count))  # Sin transponer la matriz

# Crear la paleta de colores viridis
color_palette <- viridis(max(count_values) + 1)  # Asegurarse que hay suficientes colores

# Configuración del gráfico con dimensiones correctas
plot(win, main="Conteo por Cuadrantes", type="n", asp=1)

# Obtener el número de filas y columnas en el conteo de cuadrantes
n_rows <- ncol(quadrant_count)
n_cols <- nrow(quadrant_count)

# Dibujar los cuadrantes con el color adecuado
for (i in 1:n_rows) {
  for (j in 1:n_cols) {
    # Obtener el valor de conteo para el cuadrante actual
    count_value <- quadrant_count[j, i]  # Acceder a la matriz correctamente
    
    # Invertir el índice de la fila
    ybottom <- (n_cols - j) / n_cols
    ytop <- (n_cols - j + 1) / n_cols
    
    # Definir las coordenadas del cuadrante actual
    xleft <- (i - 1) / n_rows
    xright <- i / n_rows
    
    # Ajustar las coordenadas según la escala de la ventana
    xleft <- xleft * diff(win$xrange) + win$xrange[1]
    xright <- xright * diff(win$xrange) + win$xrange[1]
    ybottom <- ybottom * diff(win$yrange) + win$yrange[1]
    ytop <- ytop * diff(win$yrange) + win$yrange[1]
    
    # Dibujar el cuadrante con el color adecuado
    rect(xleft, ybottom, xright, ytop, col = color_palette[count_value + 1], border = "black")
    
    # Añadir el número en el centro del cuadrante
    text((xleft + xright) / 2, (ybottom + ytop) / 2, labels = count_value, col = "white", cex = 0.8)
  }
}
plot(quadratcount(offspring_points, nx = 8, ny = 8))
```
```{r}
#Estimaciones de sigma 
estimacion1<-bw.diggle(offspring_points)
estimacion2<-bw.ppl(offspring_points)
estimacion3<-bw.scott(offspring_points)
g1<-plot(density.ppp(offspring_points,sigma = 0.04,edge = T),main=paste("Ancho de Banda:0.04"))
g2<-plot(density.ppp(offspring_points,sigma = 0.05,edge = T),main=paste("Ancho de Banda:0.05"))
g3<-plot(density.ppp(offspring_points,sigma = 0.09,edge = T),main=paste("Ancho de Banda:0.09"))
g4<-plot(density.ppp(offspring_points,sigma = 0.15,edge = T),main=paste("Ancho de Banda:0.15"))
estimacion1
estimacion2
estimacion3[1]
estimacion3[2]
grid.arrange(g1,g2,g3,g4,ncol=2)
```
```{r}
# Ajustar el layout para 2 filas y 2 columnas y reducir márgenes
par(mfrow = c(2, 2), mar = c(0, 0, 1, 0), oma = c(0, 0, 0, 0))

# Graficar cada densidad en su respectivo lugar
plot(density.ppp(offspring_points, sigma = 0.01, edge = TRUE), main = "Ancho de Banda: 0.01")
plot(density.ppp(offspring_points, sigma = 0.07, edge = TRUE), main = "Ancho de Banda: 0.07")
plot(density.ppp(offspring_points, sigma = 0.1, edge = TRUE), main = "Ancho de Banda: 0.1")
plot(density.ppp(offspring_points, sigma = 0.2, edge = TRUE), main = "Ancho de Banda: 0.2")
```
```{r}
K_function <- Kest(offspring_points)
summary(K_function)
plot(K_function, main = "Función K(r)")
K_functioninom <- Kinhom(offspring_points,r = seq(0,0.15,by=0.01),correction = "border")
summary(K_functioninom)
plot(K_functioninom, main = "")

```

